%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{コンストラクタ}
クラスのインスタンス化はコンストラクタによって行われる．
また，クラスが破棄される際はデストラクタが呼ばれる．
それぞれ\cdref{cd:cl02}のように宣言される．
\lstinputlisting[caption=constructor ans destoructor,label=cd:cl02]{code/class/02.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{copy コンストラクタ}
C++ではcopyによってインスタンスを生成する際の特殊なコンストラクタを定義できる．
インスタンスのcopyは2種類あり，
引数としてインスタンスを渡してcopyするcopyコンストラクタと
インスタンスを代入する形で渡すcopy代入演算子である．
それぞれ\cdref{cd:cl03}のように宣言される．
\lstinputlisting[caption=copy constructor,label=cd:cl03]{code/class/03.cpp}

copy代入演算子は定義する上で自己代入に注意する必要がある．
自己代入チェックを怠った場合，ポインタ周りで不具合が起きてしまう．
自己代入の防止は条件分岐によるチェックをするか，
\cdref{cd:cl04}に示すようなswapを用いたテクニックを使うと良いだろう．
また，次節で示すmove代入演算子を用いたテクニックもあり，
可能であればこのテクニックを用いるのが良い．
\lstinputlisting[caption=prevent self substitution by using swap,label=cd:cl04]{code/class/04.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{move コンストラクタ}
コンストラクタはcopyだけでなくmoveを用いたコンストラクタも定義できる．
インスタンスのmoveもcopyと同様2種類あり，
引数としてインスタンスを渡してmoveするmoveコンストラクタと
インスタンスを代入する形で渡すmove代入演算子である．
それぞれ\cdref{cd:cl05}のように宣言される．
\lstinputlisting[caption=move constructor,label=cd:cl05]{code/class/05.cpp}

また，move代入演算子を適切に定義できていれば，
前節で述べたコピー代入演算子における自己代入を
\cdref{cd:cl06}のようなテクニックで回避することができる．
\lstinputlisting[caption=prevent self substitution by using move,label=cd:cl06]{code/class/06.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{noexcept}
noexceptは関数が例外を送出しないことを明示的に宣言するキーワードである．
例外を送出しない保証があることでコンパイル時点でパフォーマンスの向上が見込める．
またvectorのemplace等，
一部の関数はnoexceptの有無により挙動が変わることがある(内部でmove\_if\_norxcept関数を用いているため)．
例を\cdref{cd:cl15}に示す．

このことから，自作クラスにおけるmoveコンストラクタにはnoexceptを付与するのが一般的である．
以上を踏まえた自作クラスの一般系は\cdref{cd:cl07}のようになる．
\lstinputlisting[caption=noexcept move constructor,label=cd:cl15]{code/class/15.cpp}
\lstinputlisting[caption=all constructor and destoructor,label=cd:cl07]{code/class/07.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{暗黙の宣言}
様々なコンストラクタを紹介したが，これらは場合に応じて暗黙的に宣言されることがある．
\tbref{tb:decl}に暗黙的な宣言が行われる場合を示す．
ただし，表は左のコンストラクタが宣言された場合にそれより右のコンストラクタの宣言がどうなるかを示している．
また，[deprecated]は暗黙的に宣言されるが推奨されないことを表す．

これらから以下の4点が言える．
\begin{itemize}
  \item 知識がない場合は通常のコンストラクタのみ宣言するか，全て宣言するかどちらかが良い
  \item defaultコンストラクタはいずれかを宣言した場合に暗黙的な宣言がされなくなる
  \item デストラクタを宣言する場合はcopy，moveコンストラクタを必ず宣言する
  \item copy，moveコンストラクタのどちらかを宣言した場合，もう一方も明示的に宣言するのが良い
\end{itemize}

\begin{table}[tb]
  \begin{center}
  \caption{Implicit declaration of constructor\cite{decl2016}}
  \label{tb:decl}
  \begin{tabular}{|c||c|c|c|c|}\hline
      & default ctor & copy ctor & move ctor & dtor \\ \hline \hline
      & default & default & defualt & default \\ \hline
      any ctor & no decl & default & defualt & default \\ \hline
      copy ctor & no decl & & no decl & default \\ \hline
      move ctor & no decl & [deprecated] & & default \\ \hline
      dtor & default & [deprecated] & [deprecated] & \\ \hline
  \end{tabular}
  \end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
